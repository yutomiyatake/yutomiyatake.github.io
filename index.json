[{"authors":null,"categories":null,"content":"Biography I am an associate professor at Cybermedia Center, Osaka University.\nMy research interests are in applied mathematics, especially in:\nnumerical analysis of differential equations, espacially Geometric Integration numerical linear algebra including continuous optimizations computational uncertainty quantification 自己紹介 大阪大学 サイバーメディアセンター コンピュータ実験科学研究部門 の准教授です．応用数学や数理工学の研究を行っています． 主に微分方程式など連続的な数学的対象に対する数値計算手法の開発とその数学解析，およびそれらの実世界やデータ科学への応用に関心があります．数値計算でお困りの方はぜひご相談ください．\nまた，理学部数学科 や 大学院情報科学研究科情報基礎数学専攻 の学生を受け入れ教育を行っています．宮武を指導教員として希望する方はこちらもご覧ください．\n研究分野 数値解析（特に微分方程式） 数値線形代数 不確実性定量化 連絡先 〒560-0043 大阪府豊中市待兼山町1-32 大阪大学 サイバーメディアセンター 601号室\n","date":1641194938,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1641194938,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Biography I am an associate professor at Cybermedia Center, Osaka University.","tags":null,"title":"Yuto Miyatake","type":"authors"},{"authors":[],"categories":[],"content":"関数を定義する際，キーワード引数を利用すると便利なことがあります．例えば反復法の終了条件として閾値（例えば最大反復回数や許容誤差）を設定することはよくありますが，デフォルトの値を設定しつつも，関数を呼び出すときに自由に変更できると便利です．キーワード引数は，引数の指定を位置ではなく名前でおこないます．以下，Jiliaにおけるキーワード引数の基本的な使い方を説明します．\n例えば，次の関数では y の値としてデフォルトで 1 が設定されていますが，関数を呼び出すときに，自由に変更することが可能です．\njulia\u0026gt; function f(x;y=1) return x+y end f (generic function with 1 method) julia\u0026gt; f(2) 3 julia\u0026gt; f(2,y=0.1) 2.1 もちろん，型を指定することもできます．\njulia\u0026gt; function g(x;y::Int64=1) return x+y end g (generic function with 1 method) julia\u0026gt; g(2,y=1) 3 julia\u0026gt; g(2,y=0.1) ERROR: TypeError: in keyword argument y, expected Int64, got Float64 Stacktrace: [1] (::getfield(Main, Symbol(\u0026#34;#kw##g\u0026#34;)))(::NamedTuple{(:y,),Tuple{Float64}}, ::typeof(g), ::Int64) at ./none:0 [2] top-level scope at REPL[15]:1 Int64 は 64-bit signed integer type なので，このように小数を代入をしようとするとエラーが起きます．\nまた，キーワード引数が二つ以上ある場合，どの順番で指定しても問題ありません．\njulia\u0026gt; function h(x;y=1,z=2) return x*y+z end h (generic function with 1 method) julia\u0026gt; h(1,z=3) 4 julia\u0026gt; h(1,z=3,y=2) 5 ","date":1643876302,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1643876302,"objectID":"de72ae59ac46e450fcae934c22d4c351","permalink":"https://yutomiyatake.github.io/post/julia_kwargs/","publishdate":"2022-02-03T17:18:22+09:00","relpermalink":"/post/julia_kwargs/","section":"post","summary":"関数を定義する際，キーワード引数を利用すると便利なことがあります．例えば反復法の終了条件として閾値（例えば最大反復回数や許容誤差）を設定することはよくありますが，デフォルトの値を設定しつつも，関数を呼び出すときに自由に変更できると便利です．キーワード引数は，引数の指定を位置ではなく名前でおこないます．以下，Jiliaにおけるキーワード引数の基本的な使い方を説明します．\n例えば，次の関数では y の値としてデフォルトで 1 が設定されていますが，関数を呼び出すときに，自由に変更することが可能です．","tags":["Julia"],"title":"関数の定義：キーワード引数","type":"post"},{"authors":[],"categories":[],"content":"科学技術計算では行列ベクトル積が頻繁に登場し，これを効率よく計算することはとても重要です． 行列サイズ $n$ に対して計算量は $\\mathrm{O}(n^2)$ ですが，行列は疎行列（ほとんどの要素が $0$）であることが多く，定義通りに計算すると $0$ を掛けたり足したりする無駄な演算が多く発生してしまいます． 以下では疎行列とベクトルの積の計算について解説します． （もっとも，Juliaで行列ベクトル積 $A\\boldsymbol{b}$ を計算するには A*b と書けばよく，これは $A$ が疎行列の場合でも同様なので，疎行列のパッケージがあることさえ知っていれば実用上は十分なことが多いのですが，とはいえ，チューニングを行ったり，上三角部分など行列の一部とベクトルの積を計算したりしたいときには，疎行列とベクトルの積がどのように計算されているか理解しておくことが重要です．）\nまず，行列 $A$ を適当に定義して，疎行列に変換してみましょう．\njulia\u0026gt; using SparseArrays julia\u0026gt; A = [1 2 5; 0 3 0; 0 4 6] 3×3 Array{Int64,2}: 1 2 5 0 3 0 0 4 6 julia\u0026gt; A = sparse(A) 3×3 SparseMatrixCSC{Int64,Int64} with 6 stored entries: [1, 1] = 1 [1, 2] = 2 [2, 2] = 3 [3, 2] = 4 [1, 3] = 5 [3, 3] = 6 マニュアルによれば，圧縮列格納方式 (CSC) が採用されています．\nstruct SparseMatrixCSC{Tv,Ti\u0026lt;:Integer} \u0026lt;: AbstractSparseMatrix{Tv,Ti} m::Int # Number of rows n::Int # Number of columns colptr::Vector{Ti} # Column i is in colptr[i]:(colptr[i+1]-1) rowval::Vector{Ti} # Row indices of stored values nzval::Vector{Tv} # Stored values, typically nonzeros end 上で定義した行列に対しては，それぞれ以下のようになっています．\njulia\u0026gt; A.m 3 julia\u0026gt; A.n 3 julia\u0026gt; A.colptr 4-element Array{Int64,1}: 1 2 5 7 julia\u0026gt; A.rowval 6-element Array{Int64,1}: 1 1 2 3 1 3 julia\u0026gt; A.nzval 6-element Array{Int64,1}: 1 2 3 4 5 6 さて，行列ベクトル積 $y=Ax$ を計算するためには，定義の通り，\n$$y_i = \\sum_{j=1}^nA_{ij}x_j$$\nをfor文で実装するのが自然ですが，\n疎行列の場合，$0$にアクセスするのは無駄 行列の要素は行ではなく列を基準に格納されている ため，少し工夫する必要があります．例えば，次のように書くのがよいでしょう．\nx = ones(A.n); y = zeros(A.n); for col = 1 : A.n idx = A.colptr[col] for i = idx : (A.colptr[col + 1] - 1) y[A.rowval[i]] += A.nzval[i] * x[col] end end 3重対角行列でテストしてみます．\nusing SparseArrays using LinearAlgebra #Tridiagonalを使うために必要 function main() function matvec(A,x) y = zeros(A.n); for col = 1 : A.n idx = A.colptr[col] for i = idx : (A.colptr[col + 1] - 1) y[A.rowval[i]] += A.nzval[i] * x[col] end end return y end n = 400000; #行列サイズ A = Tridiagonal(ones(n-1),-2ones(n),ones(n-1)); #三重対角行列 A = sparse(A); #疎行列に # あるいは最初から # A = spdiagm(1=\u0026gt;ones(n-1),0=\u0026gt;-2*ones(n),-1=\u0026gt;ones(n-1)) x = ones(n); @time matvec(A,x); #時間測定 end main() 計算時間は行列サイズ $n$ にほぼ比例するはずです（行列サイズが2倍になれば計算時間も約2倍）．\n","date":1643760813,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1643760813,"objectID":"cc63288a76990384ce24e8544e3353bc","permalink":"https://yutomiyatake.github.io/post/julia_mat_vec/","publishdate":"2022-02-02T09:13:33+09:00","relpermalink":"/post/julia_mat_vec/","section":"post","summary":"科学技術計算では行列ベクトル積が頻繁に登場し，これを効率よく計算することはとても重要です． 行列サイズ $n$ に対して計算量は $\\mathrm{O}(n^2)$ ですが，行列は疎行列（ほとんどの要素が $0$）であることが多く，定義通りに計算すると $0$ を掛けたり足したりする無駄な演算が多く発生してしまいます． 以下では疎行列とベクトルの積の計算について解説します． （もっとも，Juliaで行列ベクトル積 $A\\boldsymbol{b}$ を計算するには A*b と書けばよく，これは $A$ が疎行列の場合でも同様なので，疎行列のパッケージがあることさえ知っていれば実用上は十分なことが多いのですが，とはいえ，チューニングを行ったり，上三角部分など行列の一部とベクトルの積を計算したりしたいときには，疎行列とベクトルの積がどのように計算されているか理解しておくことが重要です．）","tags":["julia"],"title":"Juliaの行列ベクトル積について（疎行列編）","type":"post"},{"authors":[],"categories":[],"content":"Matlabで図を描いたとき，通常，図の背景は白です．論文を書くときなどはこれで困らないのですが，スライドに貼り付けると，背景が「真っ白」ではない場合，少し微妙な出来栄えになってしまいます．\nそんなとき，背景が透明な図を描ければよいのですが，matlabの場合は次のように実現可能です．\nset(gcf, \u0026#39;Color\u0026#39;, \u0026#39;none\u0026#39;); % figureの背景を透明に設定 set(gca, \u0026#39;Color\u0026#39;, \u0026#39;none\u0026#39;); % axisの背景を透明に設定 set(gcf, \u0026#39;InvertHardCopy\u0026#39;, \u0026#39;off\u0026#39;); % figureの背景を白でコピーする設定を外す saveas(gcf, \u0026#39;test.pdf\u0026#39;); ","date":1643724272,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1643724272,"objectID":"ffb02f04500b56a878c4c48078e32d28","permalink":"https://yutomiyatake.github.io/post/matlab-transparency/","publishdate":"2022-02-01T23:04:32+09:00","relpermalink":"/post/matlab-transparency/","section":"post","summary":"Matlabで図を描いたとき，通常，図の背景は白です．論文を書くときなどはこれで困らないのですが，スライドに貼り付けると，背景が「真っ白」ではない場合，少し微妙な出来栄えになってしまいます．\nそんなとき，背景が透明な図を描ければよいのですが，matlabの場合は次のように実現可能です．\nset(gcf, 'Color', 'none'); % figureの背景を透明に設定 set(gca, 'Color', 'none'); % axisの背景を透明に設定 set(gcf, 'InvertHardCopy', 'off'); % figureの背景を白でコピーする設定を外す saveas(gcf, 'test.","tags":["matlab"],"title":"Matlabで描く図の背景の透明化","type":"post"},{"authors":[],"categories":[],"content":"Matlabなどで図を描き，PDFで保存すると，想定外に余白が大きすぎることがあり，TeXで貼り付けるときに少々困ります．そんなときは，ターミナルから\npdfcrop test.pdf とすれば余白は最小化されます．なお，TeXをTeX Liveでインストールしていればpdfcropは標準でインストールされているはずです．\n（以下は何年も前の情報で，ここ数年，次のようなトラブルには遭遇していませんが，以前のwebページに載せていた情報をそのまま掲載します）\nこのpdfcropですが，ghostscript関係でエラーが起こることがあります．これは，TeXのインストール時に同時にインストールされるghostscriptとは別にhomebrewなどでghostscriptをインストールした場合に発生するようです．そんなときはターミナルから\nbrew link --overwrite ghostscript とすれば解決するようです．\n","date":1643680384,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1643680384,"objectID":"26e3dd9becb9c24f4f6d44e35f5c5251","permalink":"https://yutomiyatake.github.io/post/pdfcrop/","publishdate":"2022-02-01T10:53:04+09:00","relpermalink":"/post/pdfcrop/","section":"post","summary":"Matlabなどで図を描き，PDFで保存すると，想定外に余白が大きすぎることがあり，TeXで貼り付けるときに少々困ります．そんなときは，ターミナルから\npdfcrop test.pdf とすれば余白は最小化されます．なお，TeXをTeX Liveでインストールしていればpdfcropは標準でインストールされているはずです．","tags":["latex"],"title":"PDFの余白を小さくする","type":"post"},{"authors":["Yuto Miyatake"],"categories":[],"content":"JuliaでLU分解を利用して連立一次方程式を数値計算するとき，枢軸選択 (pivoting) に注意する必要があります．みるべき情報はここですが，備忘録も兼ねてまとめておきます．\njulia\u0026gt; using LinearAlgebra julia\u0026gt; A = [0 0 2; 1 0 1 ; 2 -1 1] 3×3 Array{Int64,2}: 0 0 2 1 0 1 2 -1 1 julia\u0026gt; L, U = lu(A) # 素直にLU分解 LU{Float64,Array{Float64,2}} L factor: 3×3 Array{Float64,2}: 1.0 0.0 0.0 0.5 1.0 0.0 0.0 0.0 1.0 U factor: 3×3 Array{Float64,2}: 2.0 -1.0 1.0 0.0 0.5 0.5 0.0 0.0 2.0 julia\u0026gt; L*U 3×3 Array{Float64,2}: 2.0 -1.0 1.0 1.0 0.0 1.0 0.0 0.0 2.0 L*UがAと一致しません．そもそもAの (1,1) 成分が 0 ですから，通常のLU分解は初手から破綻してしまいます．では何が行われているかというと枢軸選択 (pivoting) が行われているわけです．要するに行の入れ替えが行われています．\njulia\u0026gt; L, U, p = lu(A) LU{Float64,Array{Float64,2}} L factor: 3×3 Array{Float64,2}: 1.0 0.0 0.0 0.5 1.0 0.0 0.0 0.0 1.0 U factor: 3×3 Array{Float64,2}: 2.0 -1.0 1.0 0.0 0.5 0.5 0.0 0.0 2.0 julia\u0026gt; p # 置換を表すベクトル 3-element Array{Int64,1}: 3 2 1 julia\u0026gt; b = [4;3;5] # 連立一次方程式の右辺ベクトル 3-element Array{Int64,1}: 4 3 5 julia\u0026gt; A\\b #　連立一次方程式の解 3-element Array{Float64,1}: 1.0 -1.0 2.0 julia\u0026gt; x1 = U\\(L\\b) # pivotingを無視して計算すると... 3-element Array{Float64,1}: 0.5 -0.5 2.5 julia\u0026gt; x2 = U\\(L\\b[p]) # pivotingを考慮して計算するにはこのようにすればよい 3-element Array{Float64,1}: 1.0 -1.0 2.0 置換を表す行列も簡単に取り出せます．\njulia\u0026gt; F = lu(A); julia\u0026gt; F.P 3×3 Array{Float64,2}: 0.0 0.0 1.0 0.0 1.0 0.0 1.0 0.0 0.0 julia\u0026gt; (F.P)*A - L*U 3×3 Array{Float64,2}: 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 なお，枢軸選択を無視してLU分解することも可能です．\njulia\u0026gt; lu(A,Val(false)) # A は上の3x3行列 ERROR: ZeroPivotException: factorization encountered one or more zero pivots. Consider switching to a pivoted LU factorization. 怒られます．(1,1) 成分が 0 なのですから当然です．しかし，枢軸選択を無視してもLU分解が動く例もあります．\njulia\u0026gt; A = [1 1; 2 1] # この行列に対して 2×2 Array{Int64,2}: 1 1 2 1 julia\u0026gt; L,U　= lu(A) #　LU分解すると LU{Float64,Array{Float64,2}} L factor: 2×2 Array{Float64,2}: 1.0 0.0 0.5 1.0 U factor: 2×2 Array{Float64,2}: 2.0 1.0 0.0 0.5 julia\u0026gt; L*U # 枢軸選択が適用されますが 2×2 Array{Float64,2}: 2.0 1.0 1.0 1.0 julia\u0026gt; L,U = lu(A,Val(false)) # このようにすれば，枢軸選択は適用されません LU{Float64,Array{Float64,2}} L factor: 2×2 Array{Float64,2}: 1.0 0.0 2.0 1.0 U factor: 2×2 Array{Float64,2}: 1.0 1.0 0.0 -1.0 julia\u0026gt; L*U # 実際に L*U が A に一致します 2×2 Array{Float64,2}: 1.0 1.0 2.0 1.0 あえて枢軸選択を行わないメリットはあまりないとは思いますが，例えば，matlabの素朴なLU分解と比較するときなどには lu(A,Val(false)) は役立つかもしれません．\n","date":1641194938,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1641194938,"objectID":"84a45c868bbb672e3e13be1184be24d9","permalink":"https://yutomiyatake.github.io/post/lu-julia/","publishdate":"2022-01-03T16:28:58+09:00","relpermalink":"/post/lu-julia/","section":"post","summary":"JuliaでLU分解を利用して連立一次方程式を数値計算するとき，枢軸選択 (pivoting) に注意する必要があります．みるべき情報はここですが，備忘録も兼ねてまとめておきます．","tags":["Julia","線形計算"],"title":"JuliaでLU分解するときの注意点","type":"post"},{"authors":["Yuto Miyatake"],"categories":[],"content":"2019年頃から個人のウェブページをMkDocsで作ってきましたが，Hugoを使ってリニューアルしました．MkDocsも十分使い勝手がよく，おそらくこれからも講義用のページはMkDocsで構成していく予定ですが，備忘録（メモ）をブログ形式で残したいと思い（日付を残したいのと，タグ付け機能を使いたいのが主な動機です），HugoのAcademicテーマを利用することにしました．\n","date":1641194293,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1641194293,"objectID":"6c8941b4f73f981b10aa75dc78543414","permalink":"https://yutomiyatake.github.io/post/initial/","publishdate":"2022-01-03T16:18:13+09:00","relpermalink":"/post/initial/","section":"post","summary":"2019年頃から個人のウェブページをMkDocsで作ってきましたが，Hugoを使ってリニューアルしました．MkDocsも十分使い勝手がよく，おそらくこれからも講義用のページはMkDocsで構成していく予定ですが，備忘録（メモ）をブログ形式で残したいと思い（日付を残したいのと，タグ付け機能を使いたいのが主な動機です），HugoのAcademicテーマを利用することにしました．","tags":[],"title":"ウェブページをリニューアルしました","type":"post"}]